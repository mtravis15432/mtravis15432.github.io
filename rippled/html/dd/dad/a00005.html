<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>rippled: CodingStyle</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">rippled
   &#160;<span id="projectnumber">0.24.0-rc1</span>
   </div>
   <div id="projectbrief">Reference implementation of the Ripple Protocol</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dd/dad/a00005.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">CodingStyle </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Write code in a clear, self-documenting style but use comments where necessary. Use Test Driven Development. It encourages designing interfaces first, before implementation. Don't Repeat Yourself, “D.R.Y.”. Put redundant code in a class so it can be re-used and unit tested. Expose as little of a class as possible. Prefer private over protected. Prefer protected over public. The smaller the interface footprint, the easier it is to write unit tests and comprehend the operation of the class. This is the Interface Segregation Principle. Use language constants (enum or static const) with descriptive names instead of hard-coded “magic numbers.” Make classes depend on as few external classes or routines as possible. Ideally, no dependencies. Don't limit flexibility of parameters by forcing the caller to use specific types where general types would work. </p>
<hr/>
<h1>Coding Standards</h1>
<p>Coding standards used here are extreme strict and consistent. The style evolved gradually over the years, incorporating generally acknowledged best-practice C++ advice, experience, and personal preference.</p>
<h2>Don't Repeat Yourself!</h2>
<p>The <a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself">Don't Repeat Yourself</a> principle summarises the essence of what it means to write good code, in all languages, at all levels.</p>
<h2>Formatting</h2>
<p>The goal of source code formatting should always be to make things as easy to read as possible. White space is used to guide the eye so that details are not overlooked. Blank lines are used to separate code into "paragraphs."</p>
<ul>
<li>No tab characters please.</li>
<li>Tab stops are set to 4 spaces.</li>
<li>Braces are indented in the <a href="http://en.wikipedia.org/wiki/Indent_style#Allman_style">Allman style</a>.</li>
<li>Always place a space before and after all binary operators, especially assignments (<code>operator=</code>).</li>
<li>The <code>!</code> operator should always be followed by a space.</li>
<li>The <code>~</code> operator should be preceded by a space, but not followed by one.</li>
<li>The <code>++</code> and <code>--</code> operators should have no spaces between the operator and the operand.</li>
<li>A space never appears before a comma, and always appears after a comma.</li>
<li>Always place a space before an opening parenthesis. One exception is if the parentheses are empty.</li>
<li>Don't put spaces after a parenthesis. A typical member function call might look like this: <code>foobar (1, 2, 3);</code></li>
<li>In general, leave a blank line before an <code>if</code> statement.</li>
<li>In general, leave a blank line after a closing brace <code>}</code>.</li>
<li>Do not place code or comments on the same line as any opening or closing brace.</li>
<li>Do not write <code>if</code> statements all-on-one-line. The exception to this is when you've got a sequence of similar <code>if</code> statements, and are aligning them all vertically to highlight their similarities.</li>
<li>In an <code>if-else</code> statement, if you surround one half of the statement with braces, you also need to put braces around the other half, to match.</li>
<li>When writing a pointer type, use this spacing: <code>SomeObject* myObject</code>. Technically, a more correct spacing would be <code>SomeObject *myObject</code>, but it makes more sense for the asterisk to be grouped with the type name, since being a pointer is part of the type, not the variable name. The only time that this can lead to any problems is when you're declaring multiple pointers of the same type in the same statement - which leads on to the next rule:</li>
<li>When declaring multiple pointers, never do so in a single statement, e.g. <code>SomeObject* p1, *p2;</code> - instead, always split them out onto separate lines and write the type name again, to make it quite clear what's going on, and avoid the danger of missing out any vital asterisks.</li>
<li>The previous point also applies to references, so always put the <code>&amp;</code> next to the type rather than the variable, e.g. <code>void foo (Thing const&amp; thing)</code>. And don't put a space on both sides of the <code>*</code> or <code>&amp;</code> - always put a space after it, but never before it.</li>
<li>The word <code>const</code> should be placed to the right of the thing that it modifies, for consistency. For example <code>int const</code> refers to an int which is const. <code>int const*</code> is a pointer to an int which is const. <code>int *const</code> is a const pointer to an int.</li>
<li>Always place a space in between the template angle brackets and the type name. Template code is already hard enough to read!</li>
</ul>
<h2>Naming conventions</h2>
<ul>
<li>Member variables and method names are written with camel-case, and never begin with a capital letter.</li>
<li>Class names are also written in camel-case, but always begin with a capital letter.</li>
<li>For global variables... well, you shouldn't have any, so it doesn't matter.</li>
<li>Class data members begin with <code>m_</code>, static data members begin with <code>s_</code>. Global variables begin with <code>g_</code>. This is so the scope of the corresponding declaration can be easily determined.</li>
<li>Avoid underscores in your names, especially leading or trailing underscores. In particular, leading underscores should be avoided, as these are often used in standard library code, so to use them in your own code looks quite jarring.</li>
<li>If you really have to write a macro for some reason, then make it all caps, with underscores to separate the words. And obviously make sure that its name is unlikely to clash with symbols used in other libraries or 3rd party code.</li>
</ul>
<h2>Types, const-correctness</h2>
<ul>
<li>If a method can (and should!) be const, make it const!</li>
<li>If a method definitely doesn't throw an exception (be careful!), mark it as <code>noexcept</code></li>
<li>When returning a temporary object, e.g. a String, the returned object should be non-const, so that if the class has a C++11 move operator, it can be used.</li>
<li>If a local variable can be const, then make it const!</li>
<li>Remember that pointers can be const as well as primitives; For example, if you have a <code>char*</code> whose contents are going to be altered, you may still be able to make the pointer itself const, e.g. <code>char* const foobar = getFoobar();</code>.</li>
<li>Do not declare all your local variables at the top of a function or method (i.e. in the old-fashioned C-style). Declare them at the last possible moment, and give them as small a scope as possible.</li>
<li>Object parameters should be passed as <code>const&amp;</code> wherever possible. Only pass a parameter as a copy-by-value object if you really need to mutate a local copy inside the method, and if making a local copy inside the method would be difficult.</li>
<li>Use portable <code>for()</code> loop variable scoping (i.e. do not have multiple for loops in the same scope that each re-declare the same variable name, as this fails on older compilers)</li>
<li>When you're testing a pointer to see if it's null, never write <code>if (myPointer)</code>. Always avoid that implicit cast-to-bool by writing it more fully: <code>if (myPointer != nullptr)</code>. And likewise, never ever write <code>if (! myPointer)</code>, instead always write <code>if (myPointer == nullptr)</code>. It is more readable that way.</li>
<li>Avoid C-style casts except when converting between primitive numeric types. Some people would say "avoid C-style casts altogether", but <code>static_cast</code> is a bit unreadable when you just want to cast an <code>int</code> to a <code>float</code>. But whenever a pointer is involved, or a non-primitive object, always use <code>static_cast</code>. And when you're reinterpreting data, always use <code>reinterpret_cast</code>.</li>
<li>Until C++ gets a universal 64-bit primitive type (part of the C++11 standard), it's best to stick to the <code>std::int64_t</code> and <code>std::uint64_t</code> typedefs.</li>
</ul>
<h2>Object lifetime and ownership</h2>
<ul>
<li>Absolutely do NOT use <code>delete</code>, <code>deleteAndZero</code>, etc. There are very very few situations where you can't use a <code>ScopedPointer</code> or some other automatic lifetime management class.</li>
<li>Do not use <code>new</code> unless there's no alternative. Whenever you type <code>new</code>, always treat it as a failure to find a better solution. If a local variable can be allocated on the stack rather than the heap, then always do so.</li>
<li>Do not ever use <code>new</code> or <code>malloc</code> to allocate a C++ array. Always use a <code>HeapBlock</code> instead.</li>
<li>And just to make it doubly clear: Never use <code>malloc</code> or <code>calloc</code>.</li>
<li>If a parent object needs to create and own some kind of child object, always use composition as your first choice. If that's not possible (e.g. if the child needs a pointer to the parent for its constructor), then use a <code>ScopedPointer</code>.</li>
<li>If possible, pass an object as a reference rather than a pointer. If possible, make it a <code>const</code> reference.</li>
<li>Obviously avoid static and global values. Sometimes there's no alternative, but if there is an alternative, then use it, no matter how much effort it involves.</li>
<li>If allocating a local POD structure (e.g. an operating-system structure in native code), and you need to initialise it with zeros, use the <code>= { 0 };</code> syntax as your first choice for doing this. If for some reason that's not appropriate, use the <code><a class="el" href="../../d5/d83/a03337.html#a710cd17b4a1aa058cb94c61e6dbdbb84">zerostruct()</a></code> function, or in case that isn't suitable, use <code><a class="el" href="../../d5/d83/a03337.html#a38033e39afc004edcf6caa9fc9c5eb45">zeromem()</a></code>. Don't use <code>memset()</code>.</li>
</ul>
<h2>Classes</h2>
<ul>
<li>Declare a class's public section first, and put its constructors and destructor first. Any protected items come next, and then private ones.</li>
<li>Use the most restrictive access-specifier possible for each member. Prefer <code>private</code> over <code>protected</code>, and <code>protected</code> over <code>public</code>. Don't expose things unnecessarily.</li>
<li>Preferred positioning for any inherited classes is to put them to the right of the class name, vertically aligned, e.g.: class Thing : public Foo, private Bar { }</li>
<li>Put a class's member variables (which should almost always be private, of course), after all the public and protected method declarations.</li>
<li>Any private methods can go towards the end of the class, after the member variables.</li>
<li>If your class does not have copy-by-value semantics, derive the class from <code>Uncopyable</code>.</li>
<li>If your class is likely to be leaked, then derive your class from <code>LeakChecked&lt;&gt;</code>.</li>
<li>Constructors that take a single parameter should be default be marked <code>explicit</code>. Obviously there are cases where you do want implicit conversion, but always think about it carefully before writing a non-explicit constructor.</li>
<li>Do not use <code>NULL</code>, <code>null</code>, or 0 for a null-pointer. And especially never use '0L', which is particulary burdensome. Use <code>nullptr</code> instead - this is the C++2011 standard, so get used to it. There's a fallback definition for <code>nullptr</code> in Beast, so it's always possible to use it even if your compiler isn't yet C++2011 compliant.</li>
<li>All the C++ 'guru' books and articles are full of excellent and detailed advice on when it's best to use inheritance vs composition. If you're not already familiar with the received wisdom in these matters, then do some reading!</li>
</ul>
<h2>Miscellaneous</h2>
<ul>
<li>Constrain the scope of identifiers to the smallest area that needs it. Consider using nested classes or classes inside functions, if doing so will expose less interface and implementation overall.</li>
<li><code>goto</code> statements should not be used at all, even if the alternative is more verbose code. The only exception is when implementing an algorithm in a function as a state machine.</li>
<li>Don't use macros! OK, obviously there are many situations where they're the right tool for the job, but treat them as a last resort. Certainly don't ever use a macro just to hold a constant value or to perform any kind of function that could have been done as a real inline function. And it goes without saying that you should give them names which aren't going to clash with other code. And <code>#undef</code> them after you've used them, if possible.</li>
<li>When using the <code>++</code> or <code>--</code> operators, never use post-increment if pre-increment could be used instead. Although it doesn't matter for primitive types, it's good practice to pre-increment since this can be much more efficient for more complex objects. In particular, if you're writing a for loop, always use pre-increment, e.g. <code>for (int = 0; i &lt; 10; ++i)</code></li>
<li>Never put an "else" statement after a "return"! This is well-explained in the LLVM coding standards...and a couple of other very good pieces of advice from the LLVM standards are in there as well.</li>
<li><p class="startli">When getting a possibly-null pointer and using it only if it's non-null, limit the scope of the pointer as much as possible - e.g. Do NOT do this: </p>
<pre class="fragment">  Foo* f = getFoo ();
  if (f != nullptr)
      f-&gt;doSomething ();
  // other code
  f-&gt;doSomething ();  // oops! f may be null!
</pre><p class="startli">..instead, prefer to write it like this, which reduces the scope of the pointer, making it impossible to write code that accidentally uses a null pointer: </p>
<pre class="fragment">  if (Foo* f = getFoo ())
      f-&gt;doSomethingElse ();

  // f is out-of-scope here, so impossible to use it if it's null
</pre><p class="startli">(This also results in smaller, cleaner code) </p>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri May 2 2014 05:29:01 for rippled by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
